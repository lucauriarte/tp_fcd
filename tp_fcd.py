# -*- coding: utf-8 -*-
"""TP_FCD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WhgerjZs8MZAIS22u88ufgrwVqfCq-OI

# Librerias y Funciones
"""

import matplotlib.pyplot as plt
import numpy as np
import math
from scipy.fft import fft,fftshift
import random

spp = 10000 #muestras por pulso

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta función genera una matriz de 0 y 1 con longitud = n
def rand_key(n):
    key = np.empty(n)
    for i in range(n):
        temp = str(random.randint(0, 1))
        key[i] = temp
    print(key)
    return(key)


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta función determina cuánto tiempo dura el tren de pulsos y cuántas muestras estamos usando considerando la cantidad de pulsos y muestras por pulso.
#Recibe la duración de un pulso como D y la cantidad de pulsos como bits
def step_range(bits):
    x = np.arange(0,bits,1/spp)
    return x


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta función define qué formato se está utilizando en la transmisión
#recibe el ciclo de trabajo entre 0 y 1 como RZ (1 si no retorna)
#ret_amp es la amplitud que tiene la transmisión como retorno a cero
#ret_amp es 0 para polar/unipolar y -1 para manchester
def define_step(value,RZ=1,ret_amp=0):
    if (RZ==1):
        y = np.full(spp,value)
    else:
        y = np.full(math.trunc(spp*RZ),value)
        y = np.append(y,np.full(math.ceil(spp*(1-RZ)),ret_amp))
    return y
#Si el porcentaje RZ da como resultado un número no entero, el valor se convertirá en un valor de retorno.
#ejemplo: 128/3 42.6666 y[0,127]--> y[41]=1 y y[42]=ret_amp
#Si esto no es deseado, cambia el trunc y el ceil en el else


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
def define_constellation(wave_format,A,M):
    if(wave_format=="M_ASK"):
        constellation_I=0
        constellation_Q=np.arange(1,M+1,1)*A/M
        return constellation_I,constellation_Q
    if(wave_format=="M_PSK"):
        x=np.arange(0,2*np.pi,2*np.pi/M)
        constellation_I=np.cos(x)
        constellation_Q=np.sin(x)
        return constellation_I,constellation_Q
    if(wave_format=="M_QAM"):
        D=int(np.sqrt(M))
        x=np.arange(-D+1,D,2)*A/D
        lenx=len(x)
        I=x
        Q=x
        constellation_I=np.array([])
        constellation_Q=np.array([])
        for i in range(lenx):
            for j in range(lenx):
                magnitude=np.sqrt(I[i]**2+Q[j]**2)
                phi=np.arctan2(I[i], Q[j])
                constellation_I=np.insert(constellation_I,D*i+j,magnitude*np.cos(phi))
                constellation_Q=np.insert(constellation_Q,D*i+j,magnitude*np.sin(phi))
        return constellation_I,constellation_Q


def Modulator_IQ(A,M,bits,fc,constellation,wave_format=""):   #M=2**n siendo n un entero
    word_l=math.trunc(math.log2(M))
    train=np.arange(0)
    x=np.arange(0,spp)
    for i in range(0,len(bits),word_l):
        word_value=0
        for j in range(0,word_l):
            word_value=word_value+(2**(word_l-1-j))*bits[i+j]
        word_value=int(word_value)
        if(wave_format=="M_ASK"):
            coef=constellation[1][word_value]
            word=coef*np.sin(2*np.pi*x/fc)
        else:
            coef_I=constellation[0][word_value]
            coef_Q=constellation[1][word_value]
            word=coef_I*np.cos(2*np.pi*x/fc)-coef_Q*np.sin(2*np.pi*x/fc)
        train=np.append(train,word)
    return train


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta función calcula el valor "y" del tren de pulsos
#A0==amplitud de un 0 A1==amplitud de un 1
#bits es la cantidad de pulsos RZ.
#ret_amp se utiliza en define_step.
def step_value(A0,A1,bits,RZ=1,ret_amp=0):
    y = np.empty(0)
    for i in range(len(bits)):
        if(bits[i]==0):
            pulse=define_step(A0,RZ,ret_amp)#El tipo de pulso está normalizado
        else:
            pulse=define_step(A1,RZ,ret_amp)#El tipo de pulso está normalizado
        y=np.append(y,pulse)
    return y


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta función transforma un número en código binario
#por ejemplo 240 = 1 1 1 1 0 0 0 0
def binary_word(word):
    iterator = word
    i=0
    length=math.trunc(np.log2(word))+1
    binword=np.empty(length)
    for i in range(length-1, -1, -1):
        bit = (iterator % 2)
        binword[i] = bit
        iterator = math.trunc(iterator / 2)
    return binword


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta función imprime un tren de pulsos que recibe A-->la amplitud
#D-->duración del pulso
#word-->número
def create_pulse_train(A,word,wave_format,RZ=1,M=2,fc=1000):
    bits=len(word)
    x=step_range(bits/math.log2(M))
    if(wave_format=="unipolarNRZ"):
        y = step_value(0,A,word)
    if(wave_format=="polarNRZ"):
        y = step_value(-A/2,A/2,word)
    if(wave_format=="unipolarRZ"):
        y = step_value(0,A,word,RZ)
    if(wave_format=="polarRZ"):
        y = step_value(-A/2,A/2,word,RZ)
    if(wave_format=="M_ASK"):
        y = Modulator_IQ(A,M,word,fc,define_constellation("M_ASK",A,M),"M_ASK")
    if(wave_format=="M_PSK"):
        y = Modulator_IQ(A,M,word,fc,define_constellation("M_PSK",A,M))
    if(wave_format=="M_QAM"):
        y = Modulator_IQ(A,M,word,fc,define_constellation("M_QAM",A,M))

    #if(wave_format=="manchester"):
        #y=step_value(-A/2,A/2,word,RZ,-A)
    return [x , y , A , bits]


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
def spectral_density(pulse_train,M=2,fc=1000):
    bits=pulse_train[3]
    K=math.log2(M)
    fourier_transform =fftshift(fft(pulse_train[1]))#Transforma los pulsos y centra la transformación con fftshift para que podamos ver todo el espectro
    fourier_abs_2=((abs(fourier_transform))**2)#toma el valor absoluto de la transformación y lo eleva al cuadrado
    spectral_value=fourier_abs_2
    spectral_range=step_range(bits/K)
    x=spectral_range
    y=spectral_value

    #BASEBAND
    #spectral_value[math.ceil(bits*spp/2)]=spectral_value[math.ceil(bits*spp/2)]*10**-5 #esto hace constante el delta en NRZ unipolar
    #x=spectral_range[math.floor((bits-bits*8/spp)*0.5*spp):math.ceil((bits+bits*8/spp)*0.5*spp)]
    #y=spectral_value[math.floor((bits-bits*8/spp)*0.5*spp):math.ceil((bits+bits*8/spp)*0.5*spp)]

    #spectral_value[2490000]=0
    #spectral_value[2510000]=0
    #MODULATIONS
    #spectral_value[math.floor(bits*spp/2/K-fc)]=0
    #spectral_value[math.ceil(bits*spp/2/K+fc)]=0
    x=spectral_range[math.floor(bits*spp/2/K-2*bits*spp/fc/K):math.ceil(bits*spp/2/K+2*bits*spp/fc/K)]
    y=spectral_value[math.floor(bits*spp/2/K-2*bits*spp/fc/K):math.ceil(bits*spp/2/K+2*bits*spp/fc/K)]
    #una ventana para hacer más claro el espectro
    return x , y

"""# EJERCICIO 1

# Nivel 1:

Se propone una simulación de formas de onda en el tiempo, y densidades
espectrales correspondientes, de al menos dos formatos de transmisión, uno de
cada uno de los dos siguientes grupos de formatos:

Grupo a: Formatos de pulso rectangular Unipolar NRZ, Unipolar RZ, Polar NRZ,
Polar RZ

Grupo b: Formatos de pulso rectangular Mánchester, AMI y formato M-ario.

También simular que es lo que sucede en los casos UNRZ y PNRZ si en lugar del
formato rectangular se utiliza un pulso de Nyquist, incluyendo el extremo del
pulso 𝑠𝑖𝑛𝑐(𝑟𝑡).
"""

# Parámetros generales
A = 1                    # Amplitud de los pulsos
n_bits = 8               # Número de bits a simular
bits = rand_key(n_bits)  # Secuencia aleatoria de bits

# --- 1. UNIPOLAR NRZ ---
pulse_unrz = create_pulse_train(A, bits, wave_format="unipolarNRZ")
spectrum_unrz = spectral_density(pulse_unrz)

# Gráfico temporal
plt.figure()
plt.plot(pulse_unrz[0], pulse_unrz[1])
plt.title("UNIPOLAR NRZ - Dominio Temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)

# Gráfico espectral
plt.figure()
plt.semilogy(spectrum_unrz[0], spectrum_unrz[1])
plt.title("UNIPOLAR NRZ - Densidad Espectral")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("Magnitud (log)")
plt.grid(True)

# --- 2. MANCHESTER ---
# Manchester se implementa como polarRZ con ret_amp = -A
pulse_manchester = [pulse_unrz[0], step_value(-A/2, A/2, bits, RZ=0.5, ret_amp=-A), A, len(bits)]
spectrum_manchester = spectral_density(pulse_manchester)

# Gráfico temporal
plt.figure()
plt.plot(pulse_manchester[0], pulse_manchester[1])
plt.title("MANCHESTER - Dominio Temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)

# Gráfico espectral
plt.figure()
plt.semilogy(spectrum_manchester[0], spectrum_manchester[1])
plt.title("MANCHESTER - Densidad Espectral")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("Magnitud (log)")
plt.grid(True)

# --- 3. UNRZ con pulso tipo sinc (Nyquist) ---

# Creamos una función sinc normalizada para reemplazar al pulso rectangular
def sinc_pulse_train(bits, A=1, Ts=1, span=6):
    """
    bits: secuencia de 0 y 1
    A: amplitud
    Ts: duración de símbolo (normalizada a 1)
    span: cuántos períodos de sinc se suman por cada bit (más = más preciso)
    """
    t = np.arange(-span*Ts, len(bits)*Ts + span*Ts, 1/spp)  # eje temporal
    signal = np.zeros_like(t)

    for i, bit in enumerate(bits):
        value = A if bit == 1 else 0
        signal += value * np.sinc((t - i*Ts)/Ts)  # suma sinc desplazada

    return t, signal

# Generamos el tren de pulsos sinc
t_sinc_unrz, y_sinc_unrz = sinc_pulse_train(bits, A)

# Transformamos al mismo formato que el resto
pulse_sinc_unrz = [t_sinc_unrz, y_sinc_unrz, A, len(bits)]
spectrum_sinc_unrz = spectral_density(pulse_sinc_unrz)

# Gráfico temporal
plt.figure()
plt.plot(t_sinc_unrz, y_sinc_unrz)
plt.title("UNIPOLAR NRZ con Pulso sinc - Dominio Temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)

# Gráfico espectral
plt.figure()
plt.semilogy(spectrum_sinc_unrz[0], spectrum_sinc_unrz[1])
plt.title("UNIPOLAR NRZ con Pulso sinc - Densidad Espectral")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("Magnitud (log)")
plt.grid(True)

plt.show()

"""# Nivel 2:

Se propone una simulación de formas de onda en el tiempo, y densidades
espectrales correspondientes de los formatos de los grupos anteriormente
mencionados, planteado como un script genérico donde se pueda elegir que
formato se desea simular, para luego mostrar sus características en el tiempo y
la frecuencia.

También simular que es lo que sucede en los casos UNRZ, PNRZ y M-ario si en
lugar del formato rectangular se utiliza un pulso de Nyquist, incluyendo el
extremo del pulso 𝑠𝑖𝑛𝑐(𝑟𝑡).

"""

# Parámetros base
A = 1
n_bits = 12
fc = 1000
M = 4
RZ = 1
ret_amp = 0

# Menu de selección del formato
print("Seleccione el formato a simular:")
print(" - unipolarNRZ")
print(" - polarNRZ")
print(" - unipolarRZ")
print(" - polarRZ")
print(" - manchester")
print(" - AMI")
print(" - M_ASK")
formato = input("Formato: ")

# Preguntamos si quiere usar pulso rectangular o sinc
print("¿Desea usar pulso rectangular o sinc (Nyquist)?")
print(" - rectangular")
print(" - sinc")
pulso_tipo = input("Tipo de pulso: ")

# Generamos bits aleatorios
bits = rand_key(n_bits)

# Función manchester
def manchester(bits, A):
    y = np.empty(0)
    for bit in bits:
        if bit == 0:
            pulse = np.append(define_step(-A, RZ, -A), define_step(A, RZ, -A))
        else:
            pulse = np.append(define_step(A, RZ, -A), define_step(-A, RZ, -A))
        y = np.append(y, pulse)
    t = np.arange(0, len(bits)*2, 1/spp)
    return [t, y, A, len(bits)*2]

# Función AMI
def ami(bits, A):
    y = np.empty(0)
    polarity = 1
    for bit in bits:
        if bit == 0:
            pulse = define_step(0)
        else:
            pulse = define_step(polarity * A)
            polarity *= -1
        y = np.append(y, pulse)
    t = step_range(len(bits))
    return [t, y, A, len(bits)]

# Función unipolarNRZ con sinc
def sinc_pulse_train_unrz(bits, A, Ts=1, span=6):
    t = np.arange(-span*Ts, len(bits)*Ts + span*Ts, 1/spp)
    y = np.zeros_like(t)
    for i, bit in enumerate(bits):
        if bit == 1:
            y += A * np.sinc((t - i*Ts)/Ts)
    return [t, y, A, len(bits)]

# Función polarNRZ con sinc
def sinc_pulse_train_pnrz(bits, A, Ts=1, span=6):
    t = np.arange(-span*Ts, len(bits)*Ts + span*Ts, 1/spp)
    y = np.zeros_like(t)
    for i, bit in enumerate(bits):
        amp = A/2 if bit == 1 else -A/2
        y += amp * np.sinc((t - i*Ts)/Ts)
    return [t, y, A, len(bits)]

# Función M-ASK con sinc
def sinc_pulse_train_mask(bits, A, M, fc, Ts=1, span=6):
    word_len = int(np.log2(M))
    constellation = define_constellation("M_ASK", A, M)
    t = np.arange(-span*Ts, len(bits)*Ts/word_len + span*Ts, 1/spp)
    y = np.zeros_like(t)
    for i in range(0, len(bits), word_len):
        word_val = 0
        for j in range(word_len):
            word_val += int(bits[i + j]) * 2**(word_len - 1 - j)
        amp = constellation[1][word_val]
        y += amp * np.sinc((t - (i/word_len)*Ts)/Ts)
    return [t, y, A, len(bits)]

# Elegimos cómo generar el tren de pulsos
if pulso_tipo == "sinc":
    if formato == "unipolarNRZ":
        pulse_train = sinc_pulse_train_unrz(bits, A)
    elif formato == "polarNRZ":
        pulse_train = sinc_pulse_train_pnrz(bits, A)
    elif formato == "M_ASK":
        pulse_train = sinc_pulse_train_mask(bits, A, M, fc)
    else:
        print(f"El formato {formato} no admite pulso sinc.")
        pulse_train = None
else:
    # Rectangular normal
    if formato == "manchester":
        pulse_train = manchester(bits, A)
    elif formato == "AMI":
        pulse_train = ami(bits, A)
    elif formato == "M_ASK":
        pulse_train = create_pulse_train(A, bits, wave_format="M_ASK", M=M, fc=fc)
    else:
        pulse_train = create_pulse_train(A, bits, wave_format=formato, RZ=RZ, M=2, fc=fc)

# Si se pudo generar el tren de pulsos, graficamos
if pulse_train:
    spectrum = spectral_density(pulse_train, M=M if "M" in formato else 2, fc=fc)

    # Gráficos
    plt.figure(figsize=(14, 5))

    # Dominio temporal
    plt.subplot(1, 2, 1)
    plt.plot(pulse_train[0], pulse_train[1])
    plt.title(f"{formato} - Pulso {pulso_tipo} - Dominio temporal")
    plt.xlabel("Tiempo [s]")
    plt.ylabel("Amplitud")

    # Dominio espectral
    plt.subplot(1, 2, 2)
    plt.semilogy(spectrum[0], spectrum[1])
    plt.title(f"{formato} - Pulso {pulso_tipo} - Espectro")
    plt.xlabel("Frecuencia [Hz]")
    plt.ylabel("Magnitud")

    plt.tight_layout()
    plt.show()

"""# Nivel 3:

Completar alguno de los dos niveles 1 o 2 con una de las siguientes opciones:

a. Una simulación de la tasa de error que presenta el sistema, como
probabilidad de error en función del parámetro 𝛾𝑏.

b. A través de un ejemplo por simulación, mostrar el efecto de la
Interferencia Inter simbólica (ISI).
"""

import numpy as np
import matplotlib.pyplot as plt

# Parámetros
A = 1              # Amplitud
N = 100             # Número de bits por simulación
RZ = 1             # No retorno
formato = "polarNRZ"  # Formato binario para la simulación
snr_db_range = np.arange(0, 11, 1)  # Valores de SNR en dB (de 0 a 10)
ber_empirical = []  # Aquí se guardarán los BER simulados

# Función que simula transmisión y detección para un valor dado de SNR
def simulate_ber(snr_db):
    snr_linear = 10**(snr_db/10)         # Convertimos dB a valor lineal
    Eb = (A**2)/2                        # Energía por bit (polar NRZ usa ±A/2 → A_eff = A/2)
    N0 = Eb / snr_linear                 # Densidad espectral de ruido
    sigma = np.sqrt(N0/2)               # Desvío estándar del ruido (AWGN)

    bits = rand_key(N)                  # Secuencia aleatoria de bits
    pulse_train = create_pulse_train(A, bits, wave_format=formato)  # Tren de pulsos
    tx_signal = pulse_train[1]         # Señal transmitida

    # Agregamos ruido gaussiano blanco
    noise = np.random.normal(0, sigma, len(tx_signal))
    rx_signal = tx_signal + noise

    # Muestreo a la mitad de cada símbolo (1 símbolo = spp muestras)
    decision_points = rx_signal[spp//2::spp]  # Tomamos una muestra por bit

    # Decisión: >0 → bit 1, <=0 → bit 0
    bits_rx = (decision_points > 0).astype(int)

    # BER (bit error rate)
    errors = np.sum(bits_rx != bits)
    ber = errors / N
    return ber

# Simulamos para cada SNR
for snr_db in snr_db_range:
    ber = simulate_ber(snr_db)
    ber_empirical.append(ber)
    print(f"SNR = {snr_db} dB → BER = {ber}")

# Graficamos resultados
plt.figure(figsize=(8, 5))
plt.semilogy(snr_db_range, ber_empirical, 'o-', label='BER simulada')
plt.title("Tasa de error (BER) vs SNR para polarNRZ")
plt.xlabel("SNR por bit (𝛾𝑏) [dB]")
plt.ylabel("BER")
plt.grid(True, which='both')
plt.legend()
plt.show()

"""# EJERCICIO 2

# Nivel 1:

Se propone una simulación de formas de onda en el tiempo, y densidades
espectrales correspondientes, de al menos dos formatos de transmisión pasabanda,
uno de cada uno de los dos siguientes grupos:

Grupo a: 2ASK, 2FSK, 2PSK

Grupo b: MASK, MPSK con valor de M tal que M ≥ 4, M = 2^n
"""

# Parámetros generales
A = 1                      # Amplitud de la señal
fc = 2000                  # Frecuencia de la portadora
n_bits = 10                # Número de bits a transmitir
bits = rand_key(n_bits)    # Generamos bits aleatorios

# Primera simulación: 2PSK (Grupo a)
print("\nSimulación 2PSK:")
pulse_train_2psk = create_pulse_train(A, bits, wave_format="M_PSK", M=2, fc=fc)
spectrum_2psk = spectral_density(pulse_train_2psk, M=2, fc=fc)

# Gráficos 2PSK
plt.figure(figsize=(10, 4))
plt.plot(pulse_train_2psk[0], pulse_train_2psk[1])
plt.title("2PSK - Dominio temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 4))
plt.semilogy(spectrum_2psk[0], spectrum_2psk[1])
plt.title("2PSK - Espectro de potencia")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("PSD [dB]")
plt.grid(True)
plt.tight_layout()
plt.show()

# Segunda simulación: 8PSK (Grupo b, M=8)
print("\nSimulación 8PSK:")
# Para 8PSK necesitamos que la cantidad de bits sea múltiplo de log2(M)
n_bits_8psk = 12          # log2(8)=3, así que usamos 12 bits para tener 4 símbolos completos
bits_8psk = rand_key(n_bits_8psk)
pulse_train_8psk = create_pulse_train(A, bits_8psk, wave_format="M_PSK", M=8, fc=fc)
spectrum_8psk = spectral_density(pulse_train_8psk, M=8, fc=fc)

# Gráficos 8PSK
plt.figure(figsize=(10, 4))
plt.plot(pulse_train_8psk[0], pulse_train_8psk[1])
plt.title("8PSK - Dominio temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 4))
plt.semilogy(spectrum_8psk[0], spectrum_8psk[1])
plt.title("8PSK - Espectro de potencia")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("PSD [dB]")
plt.grid(True)
plt.tight_layout()
plt.show()

"""# Nivel 2:

Se propone una simulación similar al nivel 1, pero planteada como un script genérico
donde se pueda elegir qué modulación digital simular y mostrar sus características
en el tiempo y la frecuencia.
"""

def simulate_digital_modulation(modulation_type, M, A=1, n_bits=None, fc=1000):
    """
    Función genérica para simular modulaciones digitales.

    Parámetros:
    - modulation_type: Tipo de modulación ('ASK', 'PSK', 'QAM')
    - M: Orden de la modulación (M=2^n)
    - A: Amplitud de la señal
    - n_bits: Número de bits a transmitir (si es None, se calcula automáticamente)
    - fc: Frecuencia de la portadora

    Retorna:
    - Diccionario con los resultados de la simulación
    """
    # Verificar que M sea potencia de 2
    if not (M > 0 and (M & (M - 1) == 0)):
        raise ValueError("M debe ser una potencia de 2")

    # Calcular bits por símbolo
    bits_per_symbol = int(math.log2(M))

    # Si no se especifica n_bits, usar un múltiplo del número de bits por símbolo
    if n_bits is None:
        n_bits = bits_per_symbol * 4  # 4 símbolos como ejemplo

    # Asegurar que n_bits sea múltiplo de bits_per_symbol
    if n_bits % bits_per_symbol != 0:
        n_bits = (n_bits // bits_per_symbol + 1) * bits_per_symbol
        print(f"Ajustando n_bits a {n_bits} para tener símbolos completos")

    # Generar bits aleatorios
    bits = rand_key(n_bits)

    # Crear el formato de onda correspondiente
    wave_format = f"M_{modulation_type}"
    pulse_train = create_pulse_train(A, bits, wave_format=wave_format, M=M, fc=fc)
    spectrum = spectral_density(pulse_train, M=M, fc=fc)

    # Graficar dominio temporal
    plt.figure(figsize=(10, 4))
    plt.plot(pulse_train[0], pulse_train[1])
    plt.title(f"{M}-{modulation_type} - Dominio temporal")
    plt.xlabel("Tiempo [s]")
    plt.ylabel("Amplitud")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    # Graficar espectro
    plt.figure(figsize=(10, 4))
    plt.semilogy(spectrum[0], spectrum[1])
    plt.title(f"{M}-{modulation_type} - Espectro de potencia")
    plt.xlabel("Frecuencia [Hz]")
    plt.ylabel("PSD [dB]")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    return {
        'bits': bits,
        'pulse_train': pulse_train,
        'spectrum': spectrum
    }

# Ejemplo de uso del script genérico
print("\nEjemplos de uso del script genérico:")

# Ejemplo 1: 2-PSK
print("\nSimulando 2-PSK:")
result_2psk = simulate_digital_modulation('PSK', M=2, n_bits=10)

# Ejemplo 2: 4-ASK
print("\nSimulando 4-ASK:")
result_4ask = simulate_digital_modulation('ASK', M=4, n_bits=12)

# Ejemplo 3: 16-QAM
print("\nSimulando 16-QAM:")
result_16qam = simulate_digital_modulation('QAM', M=16, n_bits=16)

"""# Nivel 3:

Implementación de la simulación de tasa de error del sistema como probabilidad
de error en función del parámetro γ_b (relación señal a ruido por bit).
"""

def add_awgn_noise(signal, snr_db):
    """
    Agrega ruido gaussiano blanco aditivo (AWGN) a la señal.

    Parámetros:
    - signal: Señal de entrada
    - snr_db: Relación señal a ruido en dB

    Retorna:
    - Señal con ruido agregado
    """
    # Calcular la potencia de la señal
    signal_power = np.mean(signal**2)

    # Calcular la potencia del ruido basada en el SNR deseado
    noise_power = signal_power / (10**(snr_db/10))

    # Generar ruido gaussiano
    noise = np.random.normal(0, np.sqrt(noise_power), len(signal))

    # Agregar el ruido a la señal
    noisy_signal = signal + noise

    return noisy_signal

def calculate_symbol_error_rate(modulation_type, M, n_symbols=1000, snr_db_range=None):
    """
    Calcula la tasa de error de símbolos para diferentes valores de SNR.

    Parámetros:
    - modulation_type: Tipo de modulación ('ASK', 'PSK', 'QAM')
    - M: Orden de la modulación
    - n_symbols: Número de símbolos a simular
    - snr_db_range: Lista de valores SNR en dB a simular

    Retorna:
    - Lista de tasas de error para cada valor de SNR
    """
    if snr_db_range is None:
        snr_db_range = np.arange(0, 21, 2)  # 0 a 20 dB en pasos de 2 dB

    # Generar bits aleatorios
    bits_per_symbol = int(np.log2(M))
    n_bits = n_symbols * bits_per_symbol
    bits = rand_key(n_bits)

    # Generar señal modulada
    signal = create_pulse_train(1, bits, wave_format=f"M_{modulation_type}", M=M, fc=1000)

    # Lista para almacenar las tasas de error
    ser = []

    # Calcular SER para cada valor de SNR
    for snr_db in snr_db_range:
        # Agregar ruido a la señal
        noisy_signal = add_awgn_noise(signal[1], snr_db)

        # Detectar símbolos (simplificado - solo comparamos amplitudes)
        errors = np.sum(np.abs(signal[1] - noisy_signal) > 0.5)
        ser.append(errors / len(signal[1]))

    return snr_db_range, ser

# Simular tasa de error para diferentes modulaciones
print("\nSimulación de tasa de error:")

# Lista de modulaciones a simular
modulations = [
    ('PSK', 2),  # BPSK
    ('PSK', 4),  # QPSK
    ('QAM', 16), # 16-QAM
]

# Rango de SNR a simular
snr_range = np.arange(0, 21, 2)

# Graficar resultados
plt.figure(figsize=(10, 6))

for mod_type, M in modulations:
    snr, ser = calculate_symbol_error_rate(mod_type, M, snr_db_range=snr_range)
    plt.semilogy(snr, ser, '-o', label=f'{M}-{mod_type}')

plt.grid(True)
plt.xlabel('SNR (dB)')
plt.ylabel('Symbol Error Rate (SER)')
plt.title('Tasa de Error de Símbolo vs SNR')
plt.legend()
plt.tight_layout()
plt.show()