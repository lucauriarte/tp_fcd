# -*- coding: utf-8 -*-
"""TP_FCD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WhgerjZs8MZAIS22u88ufgrwVqfCq-OI

# Librerias y Funciones
"""

import matplotlib.pyplot as plt
import numpy as np
import math
from scipy.fft import fft,fftshift
import random

spp = 10000 #muestras por pulso

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta funci√≥n genera una matriz de 0 y 1 con longitud = n
def rand_key(n):
    key = np.empty(n)
    for i in range(n):
        temp = str(random.randint(0, 1))
        key[i] = temp
    print(key)
    return(key)


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta funci√≥n determina cu√°nto tiempo dura el tren de pulsos y cu√°ntas muestras estamos usando considerando la cantidad de pulsos y muestras por pulso.
#Recibe la duraci√≥n de un pulso como D y la cantidad de pulsos como bits
def step_range(bits):
    x = np.arange(0,bits,1/spp)
    return x


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta funci√≥n define qu√© formato se est√° utilizando en la transmisi√≥n
#recibe el ciclo de trabajo entre 0 y 1 como RZ (1 si no retorna)
#ret_amp es la amplitud que tiene la transmisi√≥n como retorno a cero
#ret_amp es 0 para polar/unipolar y -1 para manchester
def define_step(value,RZ=1,ret_amp=0):
    if (RZ==1):
        y = np.full(spp,value)
    else:
        y = np.full(math.trunc(spp*RZ),value)
        y = np.append(y,np.full(math.ceil(spp*(1-RZ)),ret_amp))
    return y
#Si el porcentaje RZ da como resultado un n√∫mero no entero, el valor se convertir√° en un valor de retorno.
#ejemplo: 128/3 42.6666 y[0,127]--> y[41]=1 y y[42]=ret_amp
#Si esto no es deseado, cambia el trunc y el ceil en el else


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
def define_constellation(wave_format,A,M):
    if(wave_format=="M_ASK"):
        constellation_I=0
        constellation_Q=np.arange(1,M+1,1)*A/M
        return constellation_I,constellation_Q
    if(wave_format=="M_PSK"):
        x=np.arange(0,2*np.pi,2*np.pi/M)
        constellation_I=np.cos(x)
        constellation_Q=np.sin(x)
        return constellation_I,constellation_Q
    if(wave_format=="M_QAM"):
        D=int(np.sqrt(M))
        x=np.arange(-D+1,D,2)*A/D
        lenx=len(x)
        I=x
        Q=x
        constellation_I=np.array([])
        constellation_Q=np.array([])
        for i in range(lenx):
            for j in range(lenx):
                magnitude=np.sqrt(I[i]**2+Q[j]**2)
                phi=np.arctan2(I[i], Q[j])
                constellation_I=np.insert(constellation_I,D*i+j,magnitude*np.cos(phi))
                constellation_Q=np.insert(constellation_Q,D*i+j,magnitude*np.sin(phi))
        return constellation_I,constellation_Q


def Modulator_IQ(A,M,bits,fc,constellation,wave_format=""):   #M=2**n siendo n un entero
    word_l=math.trunc(math.log2(M))
    train=np.arange(0)
    x=np.arange(0,spp)
    for i in range(0,len(bits),word_l):
        word_value=0
        for j in range(0,word_l):
            word_value=word_value+(2**(word_l-1-j))*bits[i+j]
        word_value=int(word_value)
        if(wave_format=="M_ASK"):
            coef=constellation[1][word_value]
            word=coef*np.sin(2*np.pi*x/fc)
        else:
            coef_I=constellation[0][word_value]
            coef_Q=constellation[1][word_value]
            word=coef_I*np.cos(2*np.pi*x/fc)-coef_Q*np.sin(2*np.pi*x/fc)
        train=np.append(train,word)
    return train


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta funci√≥n calcula el valor "y" del tren de pulsos
#A0==amplitud de un 0 A1==amplitud de un 1
#bits es la cantidad de pulsos RZ.
#ret_amp se utiliza en define_step.
def step_value(A0,A1,bits,RZ=1,ret_amp=0):
    y = np.empty(0)
    for i in range(len(bits)):
        if(bits[i]==0):
            pulse=define_step(A0,RZ,ret_amp)#El tipo de pulso est√° normalizado
        else:
            pulse=define_step(A1,RZ,ret_amp)#El tipo de pulso est√° normalizado
        y=np.append(y,pulse)
    return y


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta funci√≥n transforma un n√∫mero en c√≥digo binario
#por ejemplo 240 = 1 1 1 1 0 0 0 0
def binary_word(word):
    iterator = word
    i=0
    length=math.trunc(np.log2(word))+1
    binword=np.empty(length)
    for i in range(length-1, -1, -1):
        bit = (iterator % 2)
        binword[i] = bit
        iterator = math.trunc(iterator / 2)
    return binword


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta funci√≥n imprime un tren de pulsos que recibe A-->la amplitud
#D-->duraci√≥n del pulso
#word-->n√∫mero
def create_pulse_train(A,word,wave_format,RZ=1,M=2,fc=1000):
    bits=len(word)
    x=step_range(bits/math.log2(M))
    if(wave_format=="unipolarNRZ"):
        y = step_value(0,A,word)
    if(wave_format=="polarNRZ"):
        y = step_value(-A/2,A/2,word)
    if(wave_format=="unipolarRZ"):
        y = step_value(0,A,word,RZ)
    if(wave_format=="polarRZ"):
        y = step_value(-A/2,A/2,word,RZ)
    if(wave_format=="M_ASK"):
        y = Modulator_IQ(A,M,word,fc,define_constellation("M_ASK",A,M),"M_ASK")
    if(wave_format=="M_PSK"):
        y = Modulator_IQ(A,M,word,fc,define_constellation("M_PSK",A,M))
    if(wave_format=="M_QAM"):
        y = Modulator_IQ(A,M,word,fc,define_constellation("M_QAM",A,M))

    #if(wave_format=="manchester"):
        #y=step_value(-A/2,A/2,word,RZ,-A)
    return [x , y , A , bits]


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
def spectral_density(pulse_train,M=2,fc=1000):
    bits=pulse_train[3]
    K=math.log2(M)
    fourier_transform =fftshift(fft(pulse_train[1]))#Transforma los pulsos y centra la transformaci√≥n con fftshift para que podamos ver todo el espectro
    fourier_abs_2=((abs(fourier_transform))**2)#toma el valor absoluto de la transformaci√≥n y lo eleva al cuadrado
    spectral_value=fourier_abs_2
    spectral_range=step_range(bits/K)
    x=spectral_range
    y=spectral_value

    #BASEBAND
    #spectral_value[math.ceil(bits*spp/2)]=spectral_value[math.ceil(bits*spp/2)]*10**-5 #esto hace constante el delta en NRZ unipolar
    #x=spectral_range[math.floor((bits-bits*8/spp)*0.5*spp):math.ceil((bits+bits*8/spp)*0.5*spp)]
    #y=spectral_value[math.floor((bits-bits*8/spp)*0.5*spp):math.ceil((bits+bits*8/spp)*0.5*spp)]

    #spectral_value[2490000]=0
    #spectral_value[2510000]=0
    #MODULATIONS
    #spectral_value[math.floor(bits*spp/2/K-fc)]=0
    #spectral_value[math.ceil(bits*spp/2/K+fc)]=0
    x=spectral_range[math.floor(bits*spp/2/K-2*bits*spp/fc/K):math.ceil(bits*spp/2/K+2*bits*spp/fc/K)]
    y=spectral_value[math.floor(bits*spp/2/K-2*bits*spp/fc/K):math.ceil(bits*spp/2/K+2*bits*spp/fc/K)]
    #una ventana para hacer m√°s claro el espectro
    return x , y

"""# EJERCICIO 1

# Nivel 1:

Se propone una simulaci√≥n de formas de onda en el tiempo, y densidades
espectrales correspondientes, de al menos dos formatos de transmisi√≥n, uno de
cada uno de los dos siguientes grupos de formatos:

Grupo a: Formatos de pulso rectangular Unipolar NRZ, Unipolar RZ, Polar NRZ,
Polar RZ

Grupo b: Formatos de pulso rectangular M√°nchester, AMI y formato M-ario.

Tambi√©n simular que es lo que sucede en los casos UNRZ y PNRZ si en lugar del
formato rectangular se utiliza un pulso de Nyquist, incluyendo el extremo del
pulso ùë†ùëñùëõùëê(ùëüùë°).
"""

A = 1                      # Amplitud del pulso
n_bits = 10                # Numero de bits a transmitir
bits = rand_key(n_bits)    # Generamos bits aleatorios

# Crear el tren de pulsos. Cambiar 'wave_format' para simular otro formato
pulse_train = create_pulse_train(A, bits, wave_format="unipolarNRZ")
# Calcular la densidad espectral de potencia
spectrum = spectral_density(pulse_train)

#Grafico en dominio temporal
plt.figure(figsize=(10, 4))                   # Crea una nueva figura de 10x4 pulgadas
plt.plot(pulse_train[0], pulse_train[1])      # Grafico del tren de pulsos
plt.title("Dominio temporal")  # Titulo
plt.xlabel("Tiempo [s]")                      # Etiqueta del eje X
plt.ylabel("Amplitud")                        # Etiqueta del eje Y
plt.grid(True)                                # Muestra grilla
plt.tight_layout()                            # Ajusta los margenes
plt.show()                                    # Muestra el grafico

#Grafico del espectro
plt.figure(figsize=(10, 4))                   # Nueva figura
plt.semilogy(spectrum[0], spectrum[1])        # Grafico espectral en escala logar√≠tmica
plt.title("Espectro de potencia")  # Titulo
plt.xlabel("Frecuencia [Hz]")                 # Etiqueta del eje X
plt.ylabel("PSD [dB]")                        # Etiqueta del eje Y
plt.grid(True)                                # Muestra grilla
plt.tight_layout()                            # Ajusta margenes
plt.show()                                    # Muestra el grafico

"""# Nivel 2:

Se propone una simulaci√≥n de formas de onda en el tiempo, y densidades
espectrales correspondientes de los formatos de los grupos anteriormente
mencionados, planteado como un script gen√©rico donde se pueda elegir que
formato se desea simular, para luego mostrar sus caracter√≠sticas en el tiempo y
la frecuencia.

Tambi√©n simular que es lo que sucede en los casos UNRZ, PNRZ y M-ario si en
lugar del formato rectangular se utiliza un pulso de Nyquist, incluyendo el
extremo del pulso ùë†ùëñùëõùëê(ùëüùë°).

"""

"""# Nivel 3:

Completar alguno de los dos niveles 1 o 2 con una de las siguientes opciones:

a. Una simulaci√≥n de la tasa de error que presenta el sistema, como
probabilidad de error en funci√≥n del par√°metro ùõæùëè.

b. A trav√©s de un ejemplo por simulaci√≥n, mostrar el efecto de la
Interferencia Inter simb√≥lica (ISI).
"""

"""# EJERCICIO 2"""

"""# Nivel 1:

Se propone una simulaci√≥n de formas de onda en el tiempo, y densidades
espectrales correspondientes, de al menos dos formatos de transmisi√≥n pasabanda,
uno de cada uno de los dos siguientes grupos:

Grupo a: 2ASK, 2FSK, 2PSK
Grupo b: MASK, MPSK con valor de M tal que M ‚â• 4, M = 2^n
"""

# Par√°metros generales
A = 1                      # Amplitud de la se√±al
fc = 1000                  # Frecuencia de la portadora
n_bits = 10                # N√∫mero de bits a transmitir
bits = rand_key(n_bits)    # Generamos bits aleatorios

# Primera simulaci√≥n: 2PSK (Grupo a)
print("\nSimulaci√≥n 2PSK:")
pulse_train_2psk = create_pulse_train(A, bits, wave_format="M_PSK", M=2, fc=fc)
spectrum_2psk = spectral_density(pulse_train_2psk, M=2, fc=fc)

# Gr√°ficos 2PSK
plt.figure(figsize=(10, 4))
plt.plot(pulse_train_2psk[0], pulse_train_2psk[1])
plt.title("2PSK - Dominio temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 4))
plt.semilogy(spectrum_2psk[0], spectrum_2psk[1])
plt.title("2PSK - Espectro de potencia")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("PSD [dB]")
plt.grid(True)
plt.tight_layout()
plt.show()

# Segunda simulaci√≥n: 8PSK (Grupo b, M=8)
print("\nSimulaci√≥n 8PSK:")
# Para 8PSK necesitamos que la cantidad de bits sea m√∫ltiplo de log2(M)
n_bits_8psk = 12          # log2(8)=3, as√≠ que usamos 12 bits para tener 4 s√≠mbolos completos
bits_8psk = rand_key(n_bits_8psk)
pulse_train_8psk = create_pulse_train(A, bits_8psk, wave_format="M_PSK", M=8, fc=fc)
spectrum_8psk = spectral_density(pulse_train_8psk, M=8, fc=fc)

# Gr√°ficos 8PSK
plt.figure(figsize=(10, 4))
plt.plot(pulse_train_8psk[0], pulse_train_8psk[1])
plt.title("8PSK - Dominio temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 4))
plt.semilogy(spectrum_8psk[0], spectrum_8psk[1])
plt.title("8PSK - Espectro de potencia")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("PSD [dB]")
plt.grid(True)
plt.tight_layout()
plt.show()

"""# Nivel 2:

Se propone una simulaci√≥n similar al nivel 1, pero planteada como un script gen√©rico
donde se pueda elegir qu√© modulaci√≥n digital simular y mostrar sus caracter√≠sticas
en el tiempo y la frecuencia.
"""

def simulate_digital_modulation(modulation_type, M, A=1, n_bits=None, fc=1000):
    """
    Funci√≥n gen√©rica para simular modulaciones digitales.
    
    Par√°metros:
    - modulation_type: Tipo de modulaci√≥n ('ASK', 'PSK', 'QAM')
    - M: Orden de la modulaci√≥n (M=2^n)
    - A: Amplitud de la se√±al
    - n_bits: N√∫mero de bits a transmitir (si es None, se calcula autom√°ticamente)
    - fc: Frecuencia de la portadora
    
    Retorna:
    - Diccionario con los resultados de la simulaci√≥n
    """
    # Verificar que M sea potencia de 2
    if not (M > 0 and (M & (M - 1) == 0)):
        raise ValueError("M debe ser una potencia de 2")
    
    # Calcular bits por s√≠mbolo
    bits_per_symbol = int(math.log2(M))
    
    # Si no se especifica n_bits, usar un m√∫ltiplo del n√∫mero de bits por s√≠mbolo
    if n_bits is None:
        n_bits = bits_per_symbol * 4  # 4 s√≠mbolos como ejemplo
    
    # Asegurar que n_bits sea m√∫ltiplo de bits_per_symbol
    if n_bits % bits_per_symbol != 0:
        n_bits = (n_bits // bits_per_symbol + 1) * bits_per_symbol
        print(f"Ajustando n_bits a {n_bits} para tener s√≠mbolos completos")
    
    # Generar bits aleatorios
    bits = rand_key(n_bits)
    
    # Crear el formato de onda correspondiente
    wave_format = f"M_{modulation_type}"
    pulse_train = create_pulse_train(A, bits, wave_format=wave_format, M=M, fc=fc)
    spectrum = spectral_density(pulse_train, M=M, fc=fc)
    
    # Graficar dominio temporal
    plt.figure(figsize=(10, 4))
    plt.plot(pulse_train[0], pulse_train[1])
    plt.title(f"{M}-{modulation_type} - Dominio temporal")
    plt.xlabel("Tiempo [s]")
    plt.ylabel("Amplitud")
    plt.grid(True)
    plt.tight_layout()
    plt.show()
    
    # Graficar espectro
    plt.figure(figsize=(10, 4))
    plt.semilogy(spectrum[0], spectrum[1])
    plt.title(f"{M}-{modulation_type} - Espectro de potencia")
    plt.xlabel("Frecuencia [Hz]")
    plt.ylabel("PSD [dB]")
    plt.grid(True)
    plt.tight_layout()
    plt.show()
    
    return {
        'bits': bits,
        'pulse_train': pulse_train,
        'spectrum': spectrum
    }

# Ejemplo de uso del script gen√©rico
print("\nEjemplos de uso del script gen√©rico:")

# Ejemplo 1: 2-PSK
print("\nSimulando 2-PSK:")
result_2psk = simulate_digital_modulation('PSK', M=2, n_bits=10)

# Ejemplo 2: 4-ASK
print("\nSimulando 4-ASK:")
result_4ask = simulate_digital_modulation('ASK', M=4, n_bits=12)

# Ejemplo 3: 16-QAM
print("\nSimulando 16-QAM:")
result_16qam = simulate_digital_modulation('QAM', M=16, n_bits=16)

"""# Nivel 3:

Implementaci√≥n de la simulaci√≥n de tasa de error del sistema como probabilidad
de error en funci√≥n del par√°metro Œ≥_b (relaci√≥n se√±al a ruido por bit).
"""

def add_awgn_noise(signal, snr_db):
    """
    Agrega ruido gaussiano blanco aditivo (AWGN) a la se√±al.
    
    Par√°metros:
    - signal: Se√±al de entrada
    - snr_db: Relaci√≥n se√±al a ruido en dB
    
    Retorna:
    - Se√±al con ruido agregado
    """
    # Calcular la potencia de la se√±al
    signal_power = np.mean(signal**2)
    
    # Calcular la potencia del ruido basada en el SNR deseado
    noise_power = signal_power / (10**(snr_db/10))
    
    # Generar ruido gaussiano
    noise = np.random.normal(0, np.sqrt(noise_power), len(signal))
    
    # Agregar el ruido a la se√±al
    noisy_signal = signal + noise
    
    return noisy_signal

def calculate_symbol_error_rate(modulation_type, M, n_symbols=1000, snr_db_range=None):
    """
    Calcula la tasa de error de s√≠mbolos para diferentes valores de SNR.
    
    Par√°metros:
    - modulation_type: Tipo de modulaci√≥n ('ASK', 'PSK', 'QAM')
    - M: Orden de la modulaci√≥n
    - n_symbols: N√∫mero de s√≠mbolos a simular
    - snr_db_range: Lista de valores SNR en dB a simular
    
    Retorna:
    - Lista de tasas de error para cada valor de SNR
    """
    if snr_db_range is None:
        snr_db_range = np.arange(0, 21, 2)  # 0 a 20 dB en pasos de 2 dB
    
    # Generar bits aleatorios
    bits_per_symbol = int(np.log2(M))
    n_bits = n_symbols * bits_per_symbol
    bits = rand_key(n_bits)
    
    # Generar se√±al modulada
    signal = create_pulse_train(1, bits, wave_format=f"M_{modulation_type}", M=M, fc=1000)
    
    # Lista para almacenar las tasas de error
    ser = []
    
    # Calcular SER para cada valor de SNR
    for snr_db in snr_db_range:
        # Agregar ruido a la se√±al
        noisy_signal = add_awgn_noise(signal[1], snr_db)
        
        # Detectar s√≠mbolos (simplificado - solo comparamos amplitudes)
        errors = np.sum(np.abs(signal[1] - noisy_signal) > 0.5)
        ser.append(errors / len(signal[1]))
    
    return snr_db_range, ser

# Simular tasa de error para diferentes modulaciones
print("\nSimulaci√≥n de tasa de error:")

# Lista de modulaciones a simular
modulations = [
    ('PSK', 2),  # BPSK
    ('PSK', 4),  # QPSK
    ('QAM', 16), # 16-QAM
]

# Rango de SNR a simular
snr_range = np.arange(0, 21, 2)

# Graficar resultados
plt.figure(figsize=(10, 6))

for mod_type, M in modulations:
    snr, ser = calculate_symbol_error_rate(mod_type, M, snr_db_range=snr_range)
    plt.semilogy(snr, ser, '-o', label=f'{M}-{mod_type}')

plt.grid(True)
plt.xlabel('SNR (dB)')
plt.ylabel('Symbol Error Rate (SER)')
plt.title('Tasa de Error de S√≠mbolo vs SNR')
plt.legend()
plt.tight_layout()
plt.show()