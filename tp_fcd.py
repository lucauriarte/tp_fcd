# -*- coding: utf-8 -*-
"""TP_FCD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WhgerjZs8MZAIS22u88ufgrwVqfCq-OI

# Librerias y Funciones
"""

import matplotlib.pyplot as plt
import numpy as np
import math
from scipy.fft import fft,fftshift
import random

spp = 10000 #muestras por pulso

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta función genera una matriz de 0 y 1 con longitud = n
def rand_key(n):
    key = np.empty(n)
    for i in range(n):
        temp = str(random.randint(0, 1))
        key[i] = temp
    print(key)
    return(key)


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta función determina cuánto tiempo dura el tren de pulsos y cuántas muestras estamos usando considerando la cantidad de pulsos y muestras por pulso.
#Recibe la duración de un pulso como D y la cantidad de pulsos como bits
def step_range(bits):
    x = np.arange(0,bits,1/spp)
    return x


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta función define qué formato se está utilizando en la transmisión
#recibe el ciclo de trabajo entre 0 y 1 como RZ (1 si no retorna)
#ret_amp es la amplitud que tiene la transmisión como retorno a cero
#ret_amp es 0 para polar/unipolar y -1 para manchester
def define_step(value,RZ=1,ret_amp=0):
    if (RZ==1):
        y = np.full(spp,value)
    else:
        y = np.full(math.trunc(spp*RZ),value)
        y = np.append(y,np.full(math.ceil(spp*(1-RZ)),ret_amp))
    return y
#Si el porcentaje RZ da como resultado un número no entero, el valor se convertirá en un valor de retorno.
#ejemplo: 128/3 42.6666 y[0,127]--> y[41]=1 y y[42]=ret_amp
#Si esto no es deseado, cambia el trunc y el ceil en el else


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
def define_constellation(wave_format,A,M):
    if(wave_format=="M_ASK"):
        constellation_I=0
        constellation_Q=np.arange(1,M+1,1)*A/M
        return constellation_I,constellation_Q
    if(wave_format=="M_PSK"):
        x=np.arange(0,2*np.pi,2*np.pi/M)
        constellation_I=np.cos(x)
        constellation_Q=np.sin(x)
        return constellation_I,constellation_Q
    if(wave_format=="M_QAM"):
        D=int(np.sqrt(M))
        x=np.arange(-D+1,D,2)*A/D
        lenx=len(x)
        I=x
        Q=x
        constellation_I=np.array([])
        constellation_Q=np.array([])
        for i in range(lenx):
            for j in range(lenx):
                magnitude=np.sqrt(I[i]**2+Q[j]**2)
                phi=np.arctan2(I[i], Q[j])
                constellation_I=np.insert(constellation_I,D*i+j,magnitude*np.cos(phi))
                constellation_Q=np.insert(constellation_Q,D*i+j,magnitude*np.sin(phi))
        return constellation_I,constellation_Q


def Modulator_IQ(A,M,bits,fc,constellation,wave_format=""):   #M=2**n siendo n un entero
    word_l=math.trunc(math.log2(M))
    train=np.arange(0)
    x=np.arange(0,spp)
    for i in range(0,len(bits),word_l):
        word_value=0
        for j in range(0,word_l):
            word_value=word_value+(2**(word_l-1-j))*bits[i+j]
        word_value=int(word_value)
        if(wave_format=="M_ASK"):
            coef=constellation[1][word_value]
            word=coef*np.sin(2*np.pi*x/fc)
        else:
            coef_I=constellation[0][word_value]
            coef_Q=constellation[1][word_value]
            word=coef_I*np.cos(2*np.pi*x/fc)-coef_Q*np.sin(2*np.pi*x/fc)
        train=np.append(train,word)
    return train


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta función calcula el valor "y" del tren de pulsos
#A0==amplitud de un 0 A1==amplitud de un 1
#bits es la cantidad de pulsos RZ.
#ret_amp se utiliza en define_step.
def step_value(A0,A1,bits,RZ=1,ret_amp=0):
    y = np.empty(0)
    for i in range(len(bits)):
        if(bits[i]==0):
            pulse=define_step(A0,RZ,ret_amp)#El tipo de pulso está normalizado
        else:
            pulse=define_step(A1,RZ,ret_amp)#El tipo de pulso está normalizado
        y=np.append(y,pulse)
    return y


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta función transforma un número en código binario
#por ejemplo 240 = 1 1 1 1 0 0 0 0
def binary_word(word):
    iterator = word
    i=0
    length=math.trunc(np.log2(word))+1
    binword=np.empty(length)
    for i in range(length-1, -1, -1):
        bit = (iterator % 2)
        binword[i] = bit
        iterator = math.trunc(iterator / 2)
    return binword


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta función imprime un tren de pulsos que recibe A-->la amplitud
#D-->duración del pulso
#word-->número
def create_pulse_train(A,word,wave_format,RZ=1,M=2,fc=1000):
    bits=len(word)
    x=step_range(bits/math.log2(M))
    if(wave_format=="unipolarNRZ"):
        y = step_value(0,A,word)
    if(wave_format=="polarNRZ"):
        y = step_value(-A/2,A/2,word)
    if(wave_format=="unipolarRZ"):
        y = step_value(0,A,word,RZ)
    if(wave_format=="polarRZ"):
        y = step_value(-A/2,A/2,word,RZ)
    if(wave_format=="M_ASK"):
        y = Modulator_IQ(A,M,word,fc,define_constellation("M_ASK",A,M),"M_ASK")
    if(wave_format=="M_PSK"):
        y = Modulator_IQ(A,M,word,fc,define_constellation("M_PSK",A,M))
    if(wave_format=="M_QAM"):
        y = Modulator_IQ(A,M,word,fc,define_constellation("M_QAM",A,M))

    #if(wave_format=="manchester"):
        #y=step_value(-A/2,A/2,word,RZ,-A)
    return [x , y , A , bits]


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
def spectral_density(pulse_train,M=2,fc=1000):
    bits=pulse_train[3]
    K=math.log2(M)
    fourier_transform =fftshift(fft(pulse_train[1]))#Transforma los pulsos y centra la transformación con fftshift para que podamos ver todo el espectro
    fourier_abs_2=((abs(fourier_transform))**2)#toma el valor absoluto de la transformación y lo eleva al cuadrado
    spectral_value=fourier_abs_2
    spectral_range=step_range(bits/K)
    x=spectral_range
    y=spectral_value

    #BASEBAND
    #spectral_value[math.ceil(bits*spp/2)]=spectral_value[math.ceil(bits*spp/2)]*10**-5 #esto hace constante el delta en NRZ unipolar
    #x=spectral_range[math.floor((bits-bits*8/spp)*0.5*spp):math.ceil((bits+bits*8/spp)*0.5*spp)]
    #y=spectral_value[math.floor((bits-bits*8/spp)*0.5*spp):math.ceil((bits+bits*8/spp)*0.5*spp)]

    #spectral_value[2490000]=0
    #spectral_value[2510000]=0
    #MODULATIONS
    #spectral_value[math.floor(bits*spp/2/K-fc)]=0
    #spectral_value[math.ceil(bits*spp/2/K+fc)]=0
    x=spectral_range[math.floor(bits*spp/2/K-2*bits*spp/fc/K):math.ceil(bits*spp/2/K+2*bits*spp/fc/K)]
    y=spectral_value[math.floor(bits*spp/2/K-2*bits*spp/fc/K):math.ceil(bits*spp/2/K+2*bits*spp/fc/K)]
    #una ventana para hacer más claro el espectro
    return x , y

"""# EJERCICIO 1

# Nivel 1:

Se propone una simulación de formas de onda en el tiempo, y densidades
espectrales correspondientes, de al menos dos formatos de transmisión, uno de
cada uno de los dos siguientes grupos de formatos:

Grupo a: Formatos de pulso rectangular Unipolar NRZ, Unipolar RZ, Polar NRZ,
Polar RZ

Grupo b: Formatos de pulso rectangular Mánchester, AMI y formato M-ario.

También simular que es lo que sucede en los casos UNRZ y PNRZ si en lugar del
formato rectangular se utiliza un pulso de Nyquist, incluyendo el extremo del
pulso 𝑠𝑖𝑛𝑐(𝑟𝑡).
"""

A = 1                      # Amplitud del pulso
n_bits = 10                # Numero de bits a transmitir
bits = rand_key(n_bits)    # Generamos bits aleatorios

# Crear el tren de pulsos. Cambiar 'wave_format' para simular otro formato
pulse_train = create_pulse_train(A, bits, wave_format="unipolarNRZ")
# Calcular la densidad espectral de potencia
spectrum = spectral_density(pulse_train)

#Grafico en dominio temporal
plt.figure(figsize=(10, 4))                   # Crea una nueva figura de 10x4 pulgadas
plt.plot(pulse_train[0], pulse_train[1])      # Grafico del tren de pulsos
plt.title("Dominio temporal")  # Titulo
plt.xlabel("Tiempo [s]")                      # Etiqueta del eje X
plt.ylabel("Amplitud")                        # Etiqueta del eje Y
plt.grid(True)                                # Muestra grilla
plt.tight_layout()                            # Ajusta los margenes
plt.show()                                    # Muestra el grafico

#Grafico del espectro
plt.figure(figsize=(10, 4))                   # Nueva figura
plt.semilogy(spectrum[0], spectrum[1])        # Grafico espectral en escala logarítmica
plt.title("Espectro de potencia")  # Titulo
plt.xlabel("Frecuencia [Hz]")                 # Etiqueta del eje X
plt.ylabel("PSD [dB]")                        # Etiqueta del eje Y
plt.grid(True)                                # Muestra grilla
plt.tight_layout()                            # Ajusta margenes
plt.show()                                    # Muestra el grafico

"""# Nivel 2:

Se propone una simulación de formas de onda en el tiempo, y densidades
espectrales correspondientes de los formatos de los grupos anteriormente
mencionados, planteado como un script genérico donde se pueda elegir que
formato se desea simular, para luego mostrar sus características en el tiempo y
la frecuencia.

También simular que es lo que sucede en los casos UNRZ, PNRZ y M-ario si en
lugar del formato rectangular se utiliza un pulso de Nyquist, incluyendo el
extremo del pulso 𝑠𝑖𝑛𝑐(𝑟𝑡).

"""

"""# Nivel 3:

Completar alguno de los dos niveles 1 o 2 con una de las siguientes opciones:

a. Una simulación de la tasa de error que presenta el sistema, como
probabilidad de error en función del parámetro 𝛾𝑏.

b. A través de un ejemplo por simulación, mostrar el efecto de la
Interferencia Inter simbólica (ISI).
"""

"""# EJERCICIO 2"""

"""# Nivel 1:

Se propone una simulación de formas de onda en el tiempo, y densidades
espectrales correspondientes, de al menos dos formatos de transmisión pasabanda,
uno de cada uno de los dos siguientes grupos:

Grupo a: 2ASK, 2FSK, 2PSK
Grupo b: MASK, MPSK con valor de M tal que M ≥ 4, M = 2^n
"""

# Parámetros generales
A = 1                      # Amplitud de la señal
fc = 1000                  # Frecuencia de la portadora
n_bits = 10                # Número de bits a transmitir
bits = rand_key(n_bits)    # Generamos bits aleatorios

# Primera simulación: 2PSK (Grupo a)
print("\nSimulación 2PSK:")
pulse_train_2psk = create_pulse_train(A, bits, wave_format="M_PSK", M=2, fc=fc)
spectrum_2psk = spectral_density(pulse_train_2psk, M=2, fc=fc)

# Gráficos 2PSK
plt.figure(figsize=(10, 4))
plt.plot(pulse_train_2psk[0], pulse_train_2psk[1])
plt.title("2PSK - Dominio temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 4))
plt.semilogy(spectrum_2psk[0], spectrum_2psk[1])
plt.title("2PSK - Espectro de potencia")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("PSD [dB]")
plt.grid(True)
plt.tight_layout()
plt.show()

# Segunda simulación: 8PSK (Grupo b, M=8)
print("\nSimulación 8PSK:")
# Para 8PSK necesitamos que la cantidad de bits sea múltiplo de log2(M)
n_bits_8psk = 12          # log2(8)=3, así que usamos 12 bits para tener 4 símbolos completos
bits_8psk = rand_key(n_bits_8psk)
pulse_train_8psk = create_pulse_train(A, bits_8psk, wave_format="M_PSK", M=8, fc=fc)
spectrum_8psk = spectral_density(pulse_train_8psk, M=8, fc=fc)

# Gráficos 8PSK
plt.figure(figsize=(10, 4))
plt.plot(pulse_train_8psk[0], pulse_train_8psk[1])
plt.title("8PSK - Dominio temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 4))
plt.semilogy(spectrum_8psk[0], spectrum_8psk[1])
plt.title("8PSK - Espectro de potencia")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("PSD [dB]")
plt.grid(True)
plt.tight_layout()
plt.show()

"""# Nivel 2:

Se propone una simulación similar al nivel 1, pero planteada como un script genérico
donde se pueda elegir qué modulación digital simular y mostrar sus características
en el tiempo y la frecuencia.
"""

def simulate_digital_modulation(modulation_type, M, A=1, n_bits=None, fc=1000):
    """
    Función genérica para simular modulaciones digitales.
    
    Parámetros:
    - modulation_type: Tipo de modulación ('ASK', 'PSK', 'QAM')
    - M: Orden de la modulación (M=2^n)
    - A: Amplitud de la señal
    - n_bits: Número de bits a transmitir (si es None, se calcula automáticamente)
    - fc: Frecuencia de la portadora
    
    Retorna:
    - Diccionario con los resultados de la simulación
    """
    # Verificar que M sea potencia de 2
    if not (M > 0 and (M & (M - 1) == 0)):
        raise ValueError("M debe ser una potencia de 2")
    
    # Calcular bits por símbolo
    bits_per_symbol = int(math.log2(M))
    
    # Si no se especifica n_bits, usar un múltiplo del número de bits por símbolo
    if n_bits is None:
        n_bits = bits_per_symbol * 4  # 4 símbolos como ejemplo
    
    # Asegurar que n_bits sea múltiplo de bits_per_symbol
    if n_bits % bits_per_symbol != 0:
        n_bits = (n_bits // bits_per_symbol + 1) * bits_per_symbol
        print(f"Ajustando n_bits a {n_bits} para tener símbolos completos")
    
    # Generar bits aleatorios
    bits = rand_key(n_bits)
    
    # Crear el formato de onda correspondiente
    wave_format = f"M_{modulation_type}"
    pulse_train = create_pulse_train(A, bits, wave_format=wave_format, M=M, fc=fc)
    spectrum = spectral_density(pulse_train, M=M, fc=fc)
    
    # Graficar dominio temporal
    plt.figure(figsize=(10, 4))
    plt.plot(pulse_train[0], pulse_train[1])
    plt.title(f"{M}-{modulation_type} - Dominio temporal")
    plt.xlabel("Tiempo [s]")
    plt.ylabel("Amplitud")
    plt.grid(True)
    plt.tight_layout()
    plt.show()
    
    # Graficar espectro
    plt.figure(figsize=(10, 4))
    plt.semilogy(spectrum[0], spectrum[1])
    plt.title(f"{M}-{modulation_type} - Espectro de potencia")
    plt.xlabel("Frecuencia [Hz]")
    plt.ylabel("PSD [dB]")
    plt.grid(True)
    plt.tight_layout()
    plt.show()
    
    return {
        'bits': bits,
        'pulse_train': pulse_train,
        'spectrum': spectrum
    }

# Ejemplo de uso del script genérico
print("\nEjemplos de uso del script genérico:")

# Ejemplo 1: 2-PSK
print("\nSimulando 2-PSK:")
result_2psk = simulate_digital_modulation('PSK', M=2, n_bits=10)

# Ejemplo 2: 4-ASK
print("\nSimulando 4-ASK:")
result_4ask = simulate_digital_modulation('ASK', M=4, n_bits=12)

# Ejemplo 3: 16-QAM
print("\nSimulando 16-QAM:")
result_16qam = simulate_digital_modulation('QAM', M=16, n_bits=16)

"""# Nivel 3:

Implementación de la simulación de tasa de error del sistema como probabilidad
de error en función del parámetro γ_b (relación señal a ruido por bit).
"""

def add_awgn_noise(signal, snr_db):
    """
    Agrega ruido gaussiano blanco aditivo (AWGN) a la señal.
    
    Parámetros:
    - signal: Señal de entrada
    - snr_db: Relación señal a ruido en dB
    
    Retorna:
    - Señal con ruido agregado
    """
    # Calcular la potencia de la señal
    signal_power = np.mean(signal**2)
    
    # Calcular la potencia del ruido basada en el SNR deseado
    noise_power = signal_power / (10**(snr_db/10))
    
    # Generar ruido gaussiano
    noise = np.random.normal(0, np.sqrt(noise_power), len(signal))
    
    # Agregar el ruido a la señal
    noisy_signal = signal + noise
    
    return noisy_signal

def calculate_symbol_error_rate(modulation_type, M, n_symbols=1000, snr_db_range=None):
    """
    Calcula la tasa de error de símbolos para diferentes valores de SNR.
    
    Parámetros:
    - modulation_type: Tipo de modulación ('ASK', 'PSK', 'QAM')
    - M: Orden de la modulación
    - n_symbols: Número de símbolos a simular
    - snr_db_range: Lista de valores SNR en dB a simular
    
    Retorna:
    - Lista de tasas de error para cada valor de SNR
    """
    if snr_db_range is None:
        snr_db_range = np.arange(0, 21, 2)  # 0 a 20 dB en pasos de 2 dB
    
    # Generar bits aleatorios
    bits_per_symbol = int(np.log2(M))
    n_bits = n_symbols * bits_per_symbol
    bits = rand_key(n_bits)
    
    # Generar señal modulada
    signal = create_pulse_train(1, bits, wave_format=f"M_{modulation_type}", M=M, fc=1000)
    
    # Lista para almacenar las tasas de error
    ser = []
    
    # Calcular SER para cada valor de SNR
    for snr_db in snr_db_range:
        # Agregar ruido a la señal
        noisy_signal = add_awgn_noise(signal[1], snr_db)
        
        # Detectar símbolos (simplificado - solo comparamos amplitudes)
        errors = np.sum(np.abs(signal[1] - noisy_signal) > 0.5)
        ser.append(errors / len(signal[1]))
    
    return snr_db_range, ser

# Simular tasa de error para diferentes modulaciones
print("\nSimulación de tasa de error:")

# Lista de modulaciones a simular
modulations = [
    ('PSK', 2),  # BPSK
    ('PSK', 4),  # QPSK
    ('QAM', 16), # 16-QAM
]

# Rango de SNR a simular
snr_range = np.arange(0, 21, 2)

# Graficar resultados
plt.figure(figsize=(10, 6))

for mod_type, M in modulations:
    snr, ser = calculate_symbol_error_rate(mod_type, M, snr_db_range=snr_range)
    plt.semilogy(snr, ser, '-o', label=f'{M}-{mod_type}')

plt.grid(True)
plt.xlabel('SNR (dB)')
plt.ylabel('Symbol Error Rate (SER)')
plt.title('Tasa de Error de Símbolo vs SNR')
plt.legend()
plt.tight_layout()
plt.show()