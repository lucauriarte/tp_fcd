# -*- coding: utf-8 -*-
"""TP_FCD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WhgerjZs8MZAIS22u88ufgrwVqfCq-OI

# Librerias y Funciones
"""

import matplotlib.pyplot as plt
import numpy as np
import math
from scipy.fft import fft,fftshift
import random

spp = 10000 #muestras por pulso

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta funciÃ³n genera una matriz de 0 y 1 con longitud = n
def rand_key(n):
    key = np.empty(n)
    for i in range(n):
        temp = str(random.randint(0, 1))
        key[i] = temp
    print(key)
    return(key)


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta funciÃ³n determina cuÃ¡nto tiempo dura el tren de pulsos y cuÃ¡ntas muestras estamos usando considerando la cantidad de pulsos y muestras por pulso.
#Recibe la duraciÃ³n de un pulso como D y la cantidad de pulsos como bits
def step_range(bits):
    x = np.arange(0,bits,1/spp)
    return x


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta funciÃ³n define quÃ© formato se estÃ¡ utilizando en la transmisiÃ³n
#recibe el ciclo de trabajo entre 0 y 1 como RZ (1 si no retorna)
#ret_amp es la amplitud que tiene la transmisiÃ³n como retorno a cero
#ret_amp es 0 para polar/unipolar y -1 para manchester
def define_step(value,RZ=1,ret_amp=0):
    if (RZ==1):
        y = np.full(spp,value)
    else:
        y = np.full(math.trunc(spp*RZ),value)
        y = np.append(y,np.full(math.ceil(spp*(1-RZ)),ret_amp))
    return y
#Si el porcentaje RZ da como resultado un nÃºmero no entero, el valor se convertirÃ¡ en un valor de retorno.
#ejemplo: 128/3 42.6666 y[0,127]--> y[41]=1 y y[42]=ret_amp
#Si esto no es deseado, cambia el trunc y el ceil en el else


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
def define_constellation(wave_format,A,M):
    if(wave_format=="M_ASK"):
        constellation_I=0
        constellation_Q=np.arange(1,M+1,1)*A/M
        return constellation_I,constellation_Q
    if(wave_format=="M_PSK"):
        x=np.arange(0,2*np.pi,2*np.pi/M)
        constellation_I=np.cos(x)
        constellation_Q=np.sin(x)
        return constellation_I,constellation_Q
    if(wave_format=="M_QAM"):
        D=int(np.sqrt(M))
        x=np.arange(-D+1,D,2)*A/D
        lenx=len(x)
        I=x
        Q=x
        constellation_I=np.array([])
        constellation_Q=np.array([])
        for i in range(lenx):
            for j in range(lenx):
                magnitude=np.sqrt(I[i]**2+Q[j]**2)
                phi=np.arctan2(I[i], Q[j])
                constellation_I=np.insert(constellation_I,D*i+j,magnitude*np.cos(phi))
                constellation_Q=np.insert(constellation_Q,D*i+j,magnitude*np.sin(phi))
        return constellation_I,constellation_Q


def Modulator_IQ(A,M,bits,fc,constellation,wave_format=""):   #M=2**n siendo n un entero
    word_l=math.trunc(math.log2(M))
    train=np.arange(0)
    x=np.arange(0,spp)
    for i in range(0,len(bits),word_l):
        word_value=0
        for j in range(0,word_l):
            word_value=word_value+(2**(word_l-1-j))*bits[i+j]
        word_value=int(word_value)
        if(wave_format=="M_ASK"):
            coef=constellation[1][word_value]
            word=coef*np.sin(2*np.pi*x/fc)
        else:
            coef_I=constellation[0][word_value]
            coef_Q=constellation[1][word_value]
            word=coef_I*np.cos(2*np.pi*x/fc)-coef_Q*np.sin(2*np.pi*x/fc)
        train=np.append(train,word)
    return train


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta funciÃ³n calcula el valor "y" del tren de pulsos
#A0==amplitud de un 0 A1==amplitud de un 1
#bits es la cantidad de pulsos RZ.
#ret_amp se utiliza en define_step.
def step_value(A0,A1,bits,RZ=1,ret_amp=0):
    y = np.empty(0)
    for i in range(len(bits)):
        if(bits[i]==0):
            pulse=define_step(A0,RZ,ret_amp)#El tipo de pulso estÃ¡ normalizado
        else:
            pulse=define_step(A1,RZ,ret_amp)#El tipo de pulso estÃ¡ normalizado
        y=np.append(y,pulse)
    return y


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta funciÃ³n transforma un nÃºmero en cÃ³digo binario
#por ejemplo 240 = 1 1 1 1 0 0 0 0
def binary_word(word):
    iterator = word
    i=0
    length=math.trunc(np.log2(word))+1
    binword=np.empty(length)
    for i in range(length-1, -1, -1):
        bit = (iterator % 2)
        binword[i] = bit
        iterator = math.trunc(iterator / 2)
    return binword


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#Esta funciÃ³n imprime un tren de pulsos que recibe A-->la amplitud
#D-->duraciÃ³n del pulso
#word-->nÃºmero
def create_pulse_train(A,word,wave_format,RZ=1,M=2,fc=1000):
    bits=len(word)
    x=step_range(bits/math.log2(M))
    if(wave_format=="unipolarNRZ"):
        y = step_value(0,A,word)
    if(wave_format=="polarNRZ"):
        y = step_value(-A/2,A/2,word)
    if(wave_format=="unipolarRZ"):
        y = step_value(0,A,word,RZ)
    if(wave_format=="polarRZ"):
        y = step_value(-A/2,A/2,word,RZ)
    if(wave_format=="M_ASK"):
        y = Modulator_IQ(A,M,word,fc,define_constellation("M_ASK",A,M),"M_ASK")
    if(wave_format=="M_PSK"):
        y = Modulator_IQ(A,M,word,fc,define_constellation("M_PSK",A,M))
    if(wave_format=="M_QAM"):
        y = Modulator_IQ(A,M,word,fc,define_constellation("M_QAM",A,M))

    #if(wave_format=="manchester"):
        #y=step_value(-A/2,A/2,word,RZ,-A)
    return [x , y , A , bits]


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
def spectral_density(pulse_train,M=2,fc=1000):
    bits=pulse_train[3]
    K=math.log2(M)
    fourier_transform =fftshift(fft(pulse_train[1]))#Transforma los pulsos y centra la transformaciÃ³n con fftshift para que podamos ver todo el espectro
    fourier_abs_2=((abs(fourier_transform))**2)#toma el valor absoluto de la transformaciÃ³n y lo eleva al cuadrado
    spectral_value=fourier_abs_2
    spectral_range=step_range(bits/K)
    x=spectral_range
    y=spectral_value

    #BASEBAND
    #spectral_value[math.ceil(bits*spp/2)]=spectral_value[math.ceil(bits*spp/2)]*10**-5 #esto hace constante el delta en NRZ unipolar
    #x=spectral_range[math.floor((bits-bits*8/spp)*0.5*spp):math.ceil((bits+bits*8/spp)*0.5*spp)]
    #y=spectral_value[math.floor((bits-bits*8/spp)*0.5*spp):math.ceil((bits+bits*8/spp)*0.5*spp)]

    #spectral_value[2490000]=0
    #spectral_value[2510000]=0
    #MODULATIONS
    #spectral_value[math.floor(bits*spp/2/K-fc)]=0
    #spectral_value[math.ceil(bits*spp/2/K+fc)]=0
    x=spectral_range[math.floor(bits*spp/2/K-2*bits*spp/fc/K):math.ceil(bits*spp/2/K+2*bits*spp/fc/K)]
    y=spectral_value[math.floor(bits*spp/2/K-2*bits*spp/fc/K):math.ceil(bits*spp/2/K+2*bits*spp/fc/K)]
    #una ventana para hacer mÃ¡s claro el espectro
    return x , y

"""# EJERCICIO 1

# Nivel 1:

Se propone una simulaciÃ³n de formas de onda en el tiempo, y densidades
espectrales correspondientes, de al menos dos formatos de transmisiÃ³n, uno de
cada uno de los dos siguientes grupos de formatos:

Grupo a: Formatos de pulso rectangular Unipolar NRZ, Unipolar RZ, Polar NRZ,
Polar RZ

Grupo b: Formatos de pulso rectangular MÃ¡nchester, AMI y formato M-ario.

TambiÃ©n simular que es lo que sucede en los casos UNRZ y PNRZ si en lugar del
formato rectangular se utiliza un pulso de Nyquist, incluyendo el extremo del
pulso ð‘ ð‘–ð‘›ð‘(ð‘Ÿð‘¡).
"""

# ParÃ¡metros generales
A = 1                    # Amplitud de los pulsos
n_bits = 8               # NÃºmero de bits a simular
bits = rand_key(n_bits)  # Secuencia aleatoria de bits

# --- 1. UNIPOLAR NRZ ---
pulse_unrz = create_pulse_train(A, bits, wave_format="unipolarNRZ")
spectrum_unrz = spectral_density(pulse_unrz)

# GrÃ¡fico temporal
plt.figure()
plt.plot(pulse_unrz[0], pulse_unrz[1])
plt.title("UNIPOLAR NRZ - Dominio Temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)

# GrÃ¡fico espectral
plt.figure()
plt.semilogy(spectrum_unrz[0], spectrum_unrz[1])
plt.title("UNIPOLAR NRZ - Densidad Espectral")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("Magnitud (log)")
plt.grid(True)

# --- 2. MANCHESTER ---
# Manchester se implementa como polarRZ con ret_amp = -A
pulse_manchester = [pulse_unrz[0], step_value(-A/2, A/2, bits, RZ=0.5, ret_amp=-A), A, len(bits)]
spectrum_manchester = spectral_density(pulse_manchester)

# GrÃ¡fico temporal
plt.figure()
plt.plot(pulse_manchester[0], pulse_manchester[1])
plt.title("MANCHESTER - Dominio Temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)

# GrÃ¡fico espectral
plt.figure()
plt.semilogy(spectrum_manchester[0], spectrum_manchester[1])
plt.title("MANCHESTER - Densidad Espectral")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("Magnitud (log)")
plt.grid(True)

# --- 3. UNRZ con pulso tipo sinc (Nyquist) ---

# Creamos una funciÃ³n sinc normalizada para reemplazar al pulso rectangular
def sinc_pulse_train(bits, A=1, Ts=1, span=6):
    """
    bits: secuencia de 0 y 1
    A: amplitud
    Ts: duraciÃ³n de sÃ­mbolo (normalizada a 1)
    span: cuÃ¡ntos perÃ­odos de sinc se suman por cada bit (mÃ¡s = mÃ¡s preciso)
    """
    t = np.arange(-span*Ts, len(bits)*Ts + span*Ts, 1/spp)  # eje temporal
    signal = np.zeros_like(t)

    for i, bit in enumerate(bits):
        value = A if bit == 1 else 0
        signal += value * np.sinc((t - i*Ts)/Ts)  # suma sinc desplazada

    return t, signal

# Generamos el tren de pulsos sinc
t_sinc_unrz, y_sinc_unrz = sinc_pulse_train(bits, A)

# Transformamos al mismo formato que el resto
pulse_sinc_unrz = [t_sinc_unrz, y_sinc_unrz, A, len(bits)]
spectrum_sinc_unrz = spectral_density(pulse_sinc_unrz)

# GrÃ¡fico temporal
plt.figure()
plt.plot(t_sinc_unrz, y_sinc_unrz)
plt.title("UNIPOLAR NRZ con Pulso sinc - Dominio Temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)

# GrÃ¡fico espectral
plt.figure()
plt.semilogy(spectrum_sinc_unrz[0], spectrum_sinc_unrz[1])
plt.title("UNIPOLAR NRZ con Pulso sinc - Densidad Espectral")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("Magnitud (log)")
plt.grid(True)

plt.show()

"""# Nivel 2:

Se propone una simulaciÃ³n de formas de onda en el tiempo, y densidades
espectrales correspondientes de los formatos de los grupos anteriormente
mencionados, planteado como un script genÃ©rico donde se pueda elegir que
formato se desea simular, para luego mostrar sus caracterÃ­sticas en el tiempo y
la frecuencia.

TambiÃ©n simular que es lo que sucede en los casos UNRZ, PNRZ y M-ario si en
lugar del formato rectangular se utiliza un pulso de Nyquist, incluyendo el
extremo del pulso ð‘ ð‘–ð‘›ð‘(ð‘Ÿð‘¡).

"""

# ParÃ¡metros base
A = 1
n_bits = 12
fc = 1000
M = 4
RZ = 1
ret_amp = 0

# Menu de selecciÃ³n del formato
print("Seleccione el formato a simular:")
print(" - unipolarNRZ")
print(" - polarNRZ")
print(" - unipolarRZ")
print(" - polarRZ")
print(" - manchester")
print(" - AMI")
print(" - M_ASK")
formato = input("Formato: ")

# Preguntamos si quiere usar pulso rectangular o sinc
print("Â¿Desea usar pulso rectangular o sinc (Nyquist)?")
print(" - rectangular")
print(" - sinc")
pulso_tipo = input("Tipo de pulso: ")

# Generamos bits aleatorios
bits = rand_key(n_bits)

# FunciÃ³n manchester
def manchester(bits, A):
    y = np.empty(0)
    for bit in bits:
        if bit == 0:
            pulse = np.append(define_step(-A, RZ, -A), define_step(A, RZ, -A))
        else:
            pulse = np.append(define_step(A, RZ, -A), define_step(-A, RZ, -A))
        y = np.append(y, pulse)
    t = np.arange(0, len(bits)*2, 1/spp)
    return [t, y, A, len(bits)*2]

# FunciÃ³n AMI
def ami(bits, A):
    y = np.empty(0)
    polarity = 1
    for bit in bits:
        if bit == 0:
            pulse = define_step(0)
        else:
            pulse = define_step(polarity * A)
            polarity *= -1
        y = np.append(y, pulse)
    t = step_range(len(bits))
    return [t, y, A, len(bits)]

# FunciÃ³n unipolarNRZ con sinc
def sinc_pulse_train_unrz(bits, A, Ts=1, span=6):
    t = np.arange(-span*Ts, len(bits)*Ts + span*Ts, 1/spp)
    y = np.zeros_like(t)
    for i, bit in enumerate(bits):
        if bit == 1:
            y += A * np.sinc((t - i*Ts)/Ts)
    return [t, y, A, len(bits)]

# FunciÃ³n polarNRZ con sinc
def sinc_pulse_train_pnrz(bits, A, Ts=1, span=6):
    t = np.arange(-span*Ts, len(bits)*Ts + span*Ts, 1/spp)
    y = np.zeros_like(t)
    for i, bit in enumerate(bits):
        amp = A/2 if bit == 1 else -A/2
        y += amp * np.sinc((t - i*Ts)/Ts)
    return [t, y, A, len(bits)]

# FunciÃ³n M-ASK con sinc
def sinc_pulse_train_mask(bits, A, M, fc, Ts=1, span=6):
    word_len = int(np.log2(M))
    constellation = define_constellation("M_ASK", A, M)
    t = np.arange(-span*Ts, len(bits)*Ts/word_len + span*Ts, 1/spp)
    y = np.zeros_like(t)
    for i in range(0, len(bits), word_len):
        word_val = 0
        for j in range(word_len):
            word_val += int(bits[i + j]) * 2**(word_len - 1 - j)
        amp = constellation[1][word_val]
        y += amp * np.sinc((t - (i/word_len)*Ts)/Ts)
    return [t, y, A, len(bits)]

# Elegimos cÃ³mo generar el tren de pulsos
if pulso_tipo == "sinc":
    if formato == "unipolarNRZ":
        pulse_train = sinc_pulse_train_unrz(bits, A)
    elif formato == "polarNRZ":
        pulse_train = sinc_pulse_train_pnrz(bits, A)
    elif formato == "M_ASK":
        pulse_train = sinc_pulse_train_mask(bits, A, M, fc)
    else:
        print(f"El formato {formato} no admite pulso sinc.")
        pulse_train = None
else:
    # Rectangular normal
    if formato == "manchester":
        pulse_train = manchester(bits, A)
    elif formato == "AMI":
        pulse_train = ami(bits, A)
    elif formato == "M_ASK":
        pulse_train = create_pulse_train(A, bits, wave_format="M_ASK", M=M, fc=fc)
    else:
        pulse_train = create_pulse_train(A, bits, wave_format=formato, RZ=RZ, M=2, fc=fc)

# Si se pudo generar el tren de pulsos, graficamos
if pulse_train:
    spectrum = spectral_density(pulse_train, M=M if "M" in formato else 2, fc=fc)

    # GrÃ¡ficos
    plt.figure(figsize=(14, 5))

    # Dominio temporal
    plt.subplot(1, 2, 1)
    plt.plot(pulse_train[0], pulse_train[1])
    plt.title(f"{formato} - Pulso {pulso_tipo} - Dominio temporal")
    plt.xlabel("Tiempo [s]")
    plt.ylabel("Amplitud")

    # Dominio espectral
    plt.subplot(1, 2, 2)
    plt.semilogy(spectrum[0], spectrum[1])
    plt.title(f"{formato} - Pulso {pulso_tipo} - Espectro")
    plt.xlabel("Frecuencia [Hz]")
    plt.ylabel("Magnitud")

    plt.tight_layout()
    plt.show()

"""# Nivel 3:

Completar alguno de los dos niveles 1 o 2 con una de las siguientes opciones:

a. Una simulaciÃ³n de la tasa de error que presenta el sistema, como
probabilidad de error en funciÃ³n del parÃ¡metro ð›¾ð‘.

b. A travÃ©s de un ejemplo por simulaciÃ³n, mostrar el efecto de la
Interferencia Inter simbÃ³lica (ISI).
"""

import numpy as np
import matplotlib.pyplot as plt

# ParÃ¡metros
A = 1              # Amplitud
N = 100             # NÃºmero de bits por simulaciÃ³n
RZ = 1             # No retorno
formato = "polarNRZ"  # Formato binario para la simulaciÃ³n
snr_db_range = np.arange(0, 11, 1)  # Valores de SNR en dB (de 0 a 10)
ber_empirical = []  # AquÃ­ se guardarÃ¡n los BER simulados

# FunciÃ³n que simula transmisiÃ³n y detecciÃ³n para un valor dado de SNR
def simulate_ber(snr_db):
    snr_linear = 10**(snr_db/10)         # Convertimos dB a valor lineal
    Eb = (A**2)/2                        # EnergÃ­a por bit (polar NRZ usa Â±A/2 â†’ A_eff = A/2)
    N0 = Eb / snr_linear                 # Densidad espectral de ruido
    sigma = np.sqrt(N0/2)               # DesvÃ­o estÃ¡ndar del ruido (AWGN)

    bits = rand_key(N)                  # Secuencia aleatoria de bits
    pulse_train = create_pulse_train(A, bits, wave_format=formato)  # Tren de pulsos
    tx_signal = pulse_train[1]         # SeÃ±al transmitida

    # Agregamos ruido gaussiano blanco
    noise = np.random.normal(0, sigma, len(tx_signal))
    rx_signal = tx_signal + noise

    # Muestreo a la mitad de cada sÃ­mbolo (1 sÃ­mbolo = spp muestras)
    decision_points = rx_signal[spp//2::spp]  # Tomamos una muestra por bit

    # DecisiÃ³n: >0 â†’ bit 1, <=0 â†’ bit 0
    bits_rx = (decision_points > 0).astype(int)

    # BER (bit error rate)
    errors = np.sum(bits_rx != bits)
    ber = errors / N
    return ber

# Simulamos para cada SNR
for snr_db in snr_db_range:
    ber = simulate_ber(snr_db)
    ber_empirical.append(ber)
    print(f"SNR = {snr_db} dB â†’ BER = {ber}")

# Graficamos resultados
plt.figure(figsize=(8, 5))
plt.semilogy(snr_db_range, ber_empirical, 'o-', label='BER simulada')
plt.title("Tasa de error (BER) vs SNR para polarNRZ")
plt.xlabel("SNR por bit (ð›¾ð‘) [dB]")
plt.ylabel("BER")
plt.grid(True, which='both')
plt.legend()
plt.show()

"""# EJERCICIO 2

# Nivel 1:

Se propone una simulaciÃ³n de formas de onda en el tiempo, y densidades
espectrales correspondientes, de al menos dos formatos de transmisiÃ³n pasabanda,
uno de cada uno de los dos siguientes grupos:

Grupo a: 2ASK, 2FSK, 2PSK

Grupo b: MASK, MPSK con valor de M tal que M â‰¥ 4, M = 2^n
"""

# ParÃ¡metros generales
A = 1                      # Amplitud de la seÃ±al
fc = 2000                  # Frecuencia de la portadora
n_bits = 10                # NÃºmero de bits a transmitir
bits = rand_key(n_bits)    # Generamos bits aleatorios

# Primera simulaciÃ³n: 2PSK (Grupo a)
print("\nSimulaciÃ³n 2PSK:")
pulse_train_2psk = create_pulse_train(A, bits, wave_format="M_PSK", M=2, fc=fc)
spectrum_2psk = spectral_density(pulse_train_2psk, M=2, fc=fc)

# GrÃ¡ficos 2PSK
plt.figure(figsize=(10, 4))
plt.plot(pulse_train_2psk[0], pulse_train_2psk[1])
plt.title("2PSK - Dominio temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 4))
plt.semilogy(spectrum_2psk[0], spectrum_2psk[1])
plt.title("2PSK - Espectro de potencia")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("PSD [dB]")
plt.grid(True)
plt.tight_layout()
plt.show()

# Segunda simulaciÃ³n: 8PSK (Grupo b, M=8)
print("\nSimulaciÃ³n 8PSK:")
# Para 8PSK necesitamos que la cantidad de bits sea mÃºltiplo de log2(M)
n_bits_8psk = 12          # log2(8)=3, asÃ­ que usamos 12 bits para tener 4 sÃ­mbolos completos
bits_8psk = rand_key(n_bits_8psk)
pulse_train_8psk = create_pulse_train(A, bits_8psk, wave_format="M_PSK", M=8, fc=fc)
spectrum_8psk = spectral_density(pulse_train_8psk, M=8, fc=fc)

# GrÃ¡ficos 8PSK
plt.figure(figsize=(10, 4))
plt.plot(pulse_train_8psk[0], pulse_train_8psk[1])
plt.title("8PSK - Dominio temporal")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 4))
plt.semilogy(spectrum_8psk[0], spectrum_8psk[1])
plt.title("8PSK - Espectro de potencia")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("PSD [dB]")
plt.grid(True)
plt.tight_layout()
plt.show()

"""# Nivel 2:

Se propone una simulaciÃ³n similar al nivel 1, pero planteada como un script genÃ©rico
donde se pueda elegir quÃ© modulaciÃ³n digital simular y mostrar sus caracterÃ­sticas
en el tiempo y la frecuencia.
"""

def simulate_digital_modulation(modulation_type, M, A=1, n_bits=None, fc=1000):
    """
    FunciÃ³n genÃ©rica para simular modulaciones digitales.

    ParÃ¡metros:
    - modulation_type: Tipo de modulaciÃ³n ('ASK', 'PSK', 'QAM')
    - M: Orden de la modulaciÃ³n (M=2^n)
    - A: Amplitud de la seÃ±al
    - n_bits: NÃºmero de bits a transmitir (si es None, se calcula automÃ¡ticamente)
    - fc: Frecuencia de la portadora

    Retorna:
    - Diccionario con los resultados de la simulaciÃ³n
    """
    # Verificar que M sea potencia de 2
    if not (M > 0 and (M & (M - 1) == 0)):
        raise ValueError("M debe ser una potencia de 2")

    # Calcular bits por sÃ­mbolo
    bits_per_symbol = int(math.log2(M))

    # Si no se especifica n_bits, usar un mÃºltiplo del nÃºmero de bits por sÃ­mbolo
    if n_bits is None:
        n_bits = bits_per_symbol * 4  # 4 sÃ­mbolos como ejemplo

    # Asegurar que n_bits sea mÃºltiplo de bits_per_symbol
    if n_bits % bits_per_symbol != 0:
        n_bits = (n_bits // bits_per_symbol + 1) * bits_per_symbol
        print(f"Ajustando n_bits a {n_bits} para tener sÃ­mbolos completos")

    # Generar bits aleatorios
    bits = rand_key(n_bits)

    # Crear el formato de onda correspondiente
    wave_format = f"M_{modulation_type}"
    pulse_train = create_pulse_train(A, bits, wave_format=wave_format, M=M, fc=fc)
    spectrum = spectral_density(pulse_train, M=M, fc=fc)

    # Graficar dominio temporal
    plt.figure(figsize=(10, 4))
    plt.plot(pulse_train[0], pulse_train[1])
    plt.title(f"{M}-{modulation_type} - Dominio temporal")
    plt.xlabel("Tiempo [s]")
    plt.ylabel("Amplitud")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    # Graficar espectro
    plt.figure(figsize=(10, 4))
    plt.semilogy(spectrum[0], spectrum[1])
    plt.title(f"{M}-{modulation_type} - Espectro de potencia")
    plt.xlabel("Frecuencia [Hz]")
    plt.ylabel("PSD [dB]")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    return {
        'bits': bits,
        'pulse_train': pulse_train,
        'spectrum': spectrum
    }

# Ejemplo de uso del script genÃ©rico
print("\nEjemplos de uso del script genÃ©rico:")

# Ejemplo 1: 2-PSK
print("\nSimulando 2-PSK:")
result_2psk = simulate_digital_modulation('PSK', M=2, n_bits=10)

# Ejemplo 2: 4-ASK
print("\nSimulando 4-ASK:")
result_4ask = simulate_digital_modulation('ASK', M=4, n_bits=12)

# Ejemplo 3: 16-QAM
print("\nSimulando 16-QAM:")
result_16qam = simulate_digital_modulation('QAM', M=16, n_bits=16)

"""# Nivel 3:

ImplementaciÃ³n de la simulaciÃ³n de tasa de error del sistema como probabilidad
de error en funciÃ³n del parÃ¡metro Î³_b (relaciÃ³n seÃ±al a ruido por bit).
"""

def add_awgn_noise(signal, snr_db):
    """
    Agrega ruido gaussiano blanco aditivo (AWGN) a la seÃ±al.

    ParÃ¡metros:
    - signal: SeÃ±al de entrada
    - snr_db: RelaciÃ³n seÃ±al a ruido en dB

    Retorna:
    - SeÃ±al con ruido agregado
    """
    # Calcular la potencia de la seÃ±al
    signal_power = np.mean(signal**2)

    # Calcular la potencia del ruido basada en el SNR deseado
    noise_power = signal_power / (10**(snr_db/10))

    # Generar ruido gaussiano
    noise = np.random.normal(0, np.sqrt(noise_power), len(signal))

    # Agregar el ruido a la seÃ±al
    noisy_signal = signal + noise

    return noisy_signal

def calculate_symbol_error_rate(modulation_type, M, n_symbols=1000, snr_db_range=None):
    """
    Calcula la tasa de error de sÃ­mbolos para diferentes valores de SNR.

    ParÃ¡metros:
    - modulation_type: Tipo de modulaciÃ³n ('ASK', 'PSK', 'QAM')
    - M: Orden de la modulaciÃ³n
    - n_symbols: NÃºmero de sÃ­mbolos a simular
    - snr_db_range: Lista de valores SNR en dB a simular

    Retorna:
    - Lista de tasas de error para cada valor de SNR
    """
    if snr_db_range is None:
        snr_db_range = np.arange(0, 21, 2)  # 0 a 20 dB en pasos de 2 dB

    # Generar bits aleatorios
    bits_per_symbol = int(np.log2(M))
    n_bits = n_symbols * bits_per_symbol
    bits = rand_key(n_bits)

    # Generar seÃ±al modulada
    signal = create_pulse_train(1, bits, wave_format=f"M_{modulation_type}", M=M, fc=1000)

    # Lista para almacenar las tasas de error
    ser = []

    # Calcular SER para cada valor de SNR
    for snr_db in snr_db_range:
        # Agregar ruido a la seÃ±al
        noisy_signal = add_awgn_noise(signal[1], snr_db)

        # Detectar sÃ­mbolos (simplificado - solo comparamos amplitudes)
        errors = np.sum(np.abs(signal[1] - noisy_signal) > 0.5)
        ser.append(errors / len(signal[1]))

    return snr_db_range, ser

# Simular tasa de error para diferentes modulaciones
print("\nSimulaciÃ³n de tasa de error:")

# Lista de modulaciones a simular
modulations = [
    ('PSK', 2),  # BPSK
    ('PSK', 4),  # QPSK
    ('QAM', 16), # 16-QAM
]

# Rango de SNR a simular
snr_range = np.arange(0, 21, 2)

# Graficar resultados
plt.figure(figsize=(10, 6))

for mod_type, M in modulations:
    snr, ser = calculate_symbol_error_rate(mod_type, M, snr_db_range=snr_range)
    plt.semilogy(snr, ser, '-o', label=f'{M}-{mod_type}')

plt.grid(True)
plt.xlabel('SNR (dB)')
plt.ylabel('Symbol Error Rate (SER)')
plt.title('Tasa de Error de SÃ­mbolo vs SNR')
plt.legend()
plt.tight_layout()
plt.show()